[[[
[[[Хабы: Ненормальное программирование]]]
[[[Заголовок: Заметки по новому языку программирования]]]
[[[Метки: новый язык программирования]]]
]]]
Итак, как вы можете наблюдать, эволюция естественных языков завершилась[[[прежде всего потому, что нет [и не предвидится] достаточно ментально сильных людей, которые могли бы как-то повлиять на развитие языков]]] [с наступлением цифровой эпохи] (также как когда-то завершилась эволюция чисел).
Подходит к концу и эволюция языков программирования [общего назначения].

В качестве "своего" кандидата на финальный[?] конкурс языков программирования я выдвигаю данный язык.
'‘<cut />’'
Сразу оговорюсь, что на данный момент язык существует лишь в форме/виде идеи и не слишком претендует на ‘практическую реализацию’[‘лично я осилил только лексический анализатор, да и тот, не уверен, что можно будет использовать практически/фактически’].

Но представьте как здорово было бы иметь возможность писать код веб-сервера в стиле PHP или даже Python (просто `print(...)`\`вывод(...)`) на [[[полноценном[‘причины неполноценности PHP и преимущества статической типизации, RAII, шаблонов и расчётов на этапе компиляции выношу за рамки данной статьи’]]/]]полнофункциональном[‘дополнительно к тому, что поддерживает Go: виртуальные функции, поддержка RAII и шаблонов, возможность выполнения заданного кода на этапе компиляции, поддержка перегрузки функций’] быстро[‘[[[быстрее Go, как старый-добрый Turbo-C или Delphi]]]хотя бы на уровне Go’]-компилируемом языке программирования.

‘Вот маленький пример кода.’{

}
(Попробуйте угадать значения букв служебных слов, а также мысленно переписать этот кусочек кода на вашем любимом языке программирования.)

А вот пример побольше (перевод Python-кода из ‘моей предыдущей статьи’[-вставить ссылку после публикации статьи-]).
‘Код’{
#(11l)‘
F calculate_sacred_number()
   A results = []

   L(hash_algorithm) hashlib:algorithms_available || Обходим все доступные хэш-алгоритмы
                                                  \\ (список включает в себя MD5, SHA...)
      I.unlikely "shake" C hash_algorithm // Пропускаем алгоритмы SHAKE, так как ...
         L.continue
      L(uppercase) 0B..1B || Проверяем варианты написания как строчными, так и ПРОПИСНЫМИ
         L(space)  0B..1B || Проверяем варианты написания с дефисом и через пробел
            L(n)   10..99 || Проверяем все двузначные числа
               A nw = :numbers[n] || Получаем текущее число, записанное словами на англ.
               I uppercase
                  nw .= upper()
               I space
                  nw .= replace(‘-’, ‘ ’)
               A ns = String(n)
               // Считаем хэш от записанного словами числа,
               A digest1 = hashlib:(hash_algorithm, nw.encode()).hexdigest()
               // а также от этого же числа, преобразованного в строку.
               A digest2 = hashlib:(hash_algorithm, ns.encode()).hexdigest()
               L 2 // Проверяем целый хэш, а также первую половину хэша
                  // Оба хэша должны начинаться на первую цифру текущего числа
                  // и заканчиваться на вторую цифру.
                  I  digest1[0] == ns[0] & digest1[@-1] == ns[1]
                   & digest2[0] == ns[0] & digest2[@-1] == ns[1]
                     results [+]= ns
                  // Берём первую половину хэша
                  digest1 = digest1[0.<@/2]
                  digest2 = digest2[0.<@/2]

   assert(results.len == 1) || Должно быть только одно "выигравшее" число
   R results[0]             || Возвращаем это число

// Based on [https://stackoverflow.com/a/8982279/2692494 ‘How do I tell Python to convert integers into words’]
A numbers = "zero one two three four five six seven eight nine".split()
numbers [+]= "ten eleven twelve thirteen fourteen fifteen sixteen".split()
numbers [+]= "seventeen eighteen nineteen".split()
L(tens) "twenty thirty forty fifty sixty seventy eighty ninety".split()
   L(ones) numbers[0..9]
      numbers [+]= I ones == "zero" {tens} E tens‘-’ones

print(calculate_sacred_number())
’
}

Н‘Развивая идею вывода типов (type inference)’

Для начала скажу про такой момент, что в предлагаемом языке существуют такие служебные функции как copy() и share().
Тип умного указателя я предлагаю определять по его использованию (также как тип массива или словаря ‘в Nemerle определяется по типу первого добавленного в него элемента’[http://nemerle.org/About#ID0ESG]). Получается эдакий autounishared_ptr — гибрид unique_ptr и shared_ptr из C++11. Если где либо в коде встречается share(p), тогда p становится shared_ptr-ом, иначе остаётся unique_ptr-ом.

Аналогично определяется где хранить объект, объявленный локально — по его использованию. Если он никуда не добавляется (ни в какой контейнер), а используется только в области, в которой был объявлен, тогда (и также если он не слишком большой) этот объект размещается на стеке, иначе [[[размещается в куче]]]выделяется в динамической памяти.

Функция copy() используется для копирования тяжелых объектов, которое, как я считаю, должно быть обозначено явно в коде (просто через `оператор =` можно копировать только лёгкие объекты).
(Более подробное описание предлагаемого мной механизма работы с памятью — это тема для отдельной статьи, но вкратце скажу, что я предлагаю модель памяти несколько отличную[‘прежде всего отличие в принятых умолчаниях’] от C++ и Rust, и более логичную, на мой взгляд.)

Задумывались ли вы над тем, что флаги открытия файла можно не указывать явно, а выводить из его использования?
#(11l)‘
A fstr = File(fname).read()  ||  А фстр = Файл(имя).прочти()
File(fname).write(contents)  ||  Файл(имя).запиши(содержимое)

I File(fname)    || заменяется компилятором на I fs:exists(fname)
File(fname).size || заменяется компилятором на fs:stat(fname).size
’

Если берётся часть строки, то результат имеет тип Строка\String или Подстрока\Substring в зависимости от использования.
Вот здесь можно использовать тип Подстрока\Substring для переменной `link`, так как переменная `link` не модифицируется:
#(11l)‘
      A link = instr[i + 1.<endb]
      I A spacepos = link.find(‘ ’)
         link = link[0.<spacepos]
      I link.len > 57
         link = link[0..(link.rfind(‘/’, 47) ?? -1)+1]‘...’
      write_http_link(i, i, 0, linkn‘<i>’link‘</i>’)’(Этот код основан на ‘7 строках из pqmarkup.py’[https://bitbucket.org/pqmarkup/pqmarkup/src/0d0354719b0f9f02a7d746ca695e32981b7e8e95/pqmarkup.py#pqmarkup.py-302].)

А если где-то в коде изменяется значение переменной `link`, то её тип устанавливается компилятором как Строка\String.
Также обратите внимание, что использование типа Подстрока\Substring в данном примере возможно благодаря тому, что `instr` — константный аргумент функции (а по умолчанию все аргументы функции целесообразно считать константными).

Признак константности также можно выводить из использования — если переменная нигде не изменяется, то к её типу компилятор может автоматически добавить спецификатор константности, после чего компилятор может полагаться на это.

[[[
Опрос:
Какое название вы бы дали предлагаемому языку программирования?
. 11a
. 11l
. 11c
]]]
