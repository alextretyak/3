[[[
[[[Хабы: Ненормальное программирование]]]
[[[Заголовок: Заметки по новому языку программирования]]]
[[[Метки: новый язык программирования]]]
]]]
Итак, как вы можете наблюдать, эволюция естественных языков завершилась[[[прежде всего потому, что нет [и не предвидится] достаточно ментально сильных людей, которые могли бы как-то повлиять на развитие языков]]] [с наступлением цифровой эпохи] (также как когда-то завершилась эволюция чисел).
Подходит к концу и эволюция языков программирования [общего назначения].

В качестве "своего" кандидата на финальный[?] конкурс языков программирования я выдвигаю данный язык.

Сразу оговорюсь, что на данный момент язык существует лишь в форме/виде идеи и не слишком претендует на ‘практическую реализацию’[‘лично я осилил только лексический анализатор, да и тот, не уверен, что можно будет использовать практически/фактически’].

Но представьте как здорово было бы иметь возможность писать код веб-сервера в стиле PHP или даже Python (просто `print(...)`\`вывод(...)`) на полноценном[‘причины неполноценности PHP и преимущества статической типизации, RAII, шаблонов и расчётов на этапе компиляции выношу за рамки данной статьи’] быстро[‘[[[быстрее Go, как старый-добрый Turbo-C или Delphi]]]хотя бы на уровне Go’]-компилируемом языке программирования.

‘Вот маленький пример кода.’{

}
(Попробуйте угадать значения букв служебных слов, а также мысленно переписать этот кусочек кода на вашем любимом языке программирования.)

А вот пример побольше (перевод Python-кода из моей ‘предыдущей статьи’[-вставить ссылку после публикации статьи-]).
‘Код’{
#(11l)‘
F calculate_sacred_number()
   A results = []

   L(hash_algorithm) hashlib:algorithms_available || Обходим все доступные хэш-алгоритмы
                                                  \\ (список включает в себя MD5, SHA...)
      I.unlikely "shake" C hash_algorithm // Пропускаем алгоритмы SHAKE, так как ...
         L.continue
      L(uppercase) 0B..1B || Проверяем варианты написания как строчными, так и ПРОПИСНЫМИ
         L(space)  0B..1B || Проверяем варианты написания с дефисом и через пробел
            L(n)   10..99 || Проверяем все двузначные числа
               A nw = :numbers[n] || Получаем текущее число, записанное словами на англ.
               I uppercase
                  nw .= upper()
               I space
                  nw .= replace(‘-’, ‘ ’)
               A ns = String(n)
               // Считаем хэш от записанного словами числа,
               A digest1 = hashlib:(hash_algorithm, nw.encode()).hexdigest()
               // а также от этого же числа, преобразованного в строку.
               A digest2 = hashlib:(hash_algorithm, ns.encode()).hexdigest()
               L 2 // Проверяем целый хэш, а также первую половину хэша
                  // Оба хэша должны начинаться на первую цифру текущего числа
                  // и заканчиваться на вторую цифру.
                  I  digest1[  0] == ns[0] & digest2[  0] == ns[0]
                   & digest1[@-1] == ns[1] & digest2[@-1] == ns[1]
                     results [+]= ns
                  // Берём первую половину хэша
                  digest1 = digest1[0.<@/2]
                  digest2 = digest2[0.<@/2]

   assert(results.len == 1) || Должно быть только одно "выигравшее" число
   R results[0]             || Возвращаем это число

// From [https://stackoverflow.com/a/8982279/2692494 ‘How do I tell Python to convert integers into words’]:
A numbers = "zero one two three four five six seven eight nine".split()
numbers [+]= "ten eleven twelve thirteen fourteen fifteen sixteen".split()
numbers [+]= "seventeen eighteen nineteen".split()
L(tens) "twenty thirty forty fifty sixty seventy eighty ninety".split()
   L(ones) numbers[0..9]
      numbers [+]= I ones == "zero" {tens} E tens‘-’ones

print(calculate_sacred_number())
’
}

[[[
Опрос:
Какое название вы бы дали предлагаемому языку программирования?
. 11a
. 11l
. 11c
]]]
